# 总体归纳 Overview
 
```ccard
type: folder_brief_live
```
 
#### 概述

代码从抽象到具体，一块芯片（stm32）包括有外设和内设，我们平时通过代码来操控外设以实现控制芯片外的设备，要访问外设就得需要知道外设的地方，外设通过地址来确定位置。stm32地址有特定的数量，每个地址区段对应不同的外设或者内设，某一段地址是一个总线，总线下有具体的外设。

最基本的操作就是直接操作对应的地址，在此基础上，可以通过操作端口配置寄存器来设置

由于操作寄存器过于复杂，在此基础上便出现了库函数，通过库函数可以不用直接和寄存器打交道，直接操作端口

#### 是如何包装的呢？

我们可以从上面知道，这些外设是有各自的地址的，stm32的外设共同排布在4g的空间内（小注：因为stm32是32位芯片，所以地址只有4gb的大小，如果是电脑的64位会有更大的地址。这也是为什么xp等32位系统最大只能支持4gb内存的原因，因为32位最大只能包含4gb的地址。）

在stm32的4gb地址空间内，有8个块，各自负责不同的功能。其中最重要的是有3个

- block0 内部flash，这里放着编写好的程序代码，内核通过icode总线来取里面的指令来运行。注意这里不仅仅有自己编写的代码，还有硬件运行的基础代码，例如看门狗啥的。
- block1 内部ram，程序的变量、堆栈等（注意这里不是代码占用空间，是代码运行的时候花费的空间。为什么会多出空间呢？代码运行的时候例如用户输入或者for循环都会花费空间）
- block2 片上外设，负责外设的地址。这里有两个大类，分别是apb和ahb两个部分，其中apb又有apb1和apb2两个部分，我记得apb2和ahb是高速外设，apb1是低速外设

知道了地址空间的划分，就要研究具体外设了。就比如最基本的gpio外设，它是从0x40010800开始的，这个0x40010800是gpio外设的基地址。

明白了基地址的定义，就能理解寄存器上地址偏移的意思，这个意思是相对于基地址往后偏移多少位。

gpio操作是通过寄存器来操作（注意我们不能直接操作具体的引脚，~~这要是能操作未免太奇怪了吧~~，所以在gpio的地址里，不是具体的引脚的地址，里面是寄存器的地址，我们通过操作寄存器来操作引脚），gpio有很多种寄存器（负责同一批端口都有不同的寄存器），这些寄存器方便操作对应的引脚。寄存器编程就是通过操控这些寄存器来操作引脚的。

而库函数就是把一堆寄存器组合起来操作。

------

上面的描述是理解基本的包装，下面是继续理解具体包装的过程（当然是通过c语言角度）。

众所周知，我们有很多很多的地址，地址是一串数字，是反人类的（doge）。我们当然不方便来直接通过一串数字来操作吧，所以要进行数字和变量对应，通过预定义`#define 变量 具体的地址`

插一嘴，这里就是stm32f10x.h文件的作用，叫做寄存器映射。~~嗯，思路有点断了差评~~

外设有这么多，总体有4gb这么多，虽然我们不必要定义所有的外设，但是单单gpio的地址就要好多好多个了，那怎么办，联系上面的地址偏移。

我们先定义基地址，在定义具体的片段的基地址，再再定义片段的片段的基地址。这样我们就能很好的找到想要的寄存器了。只需要知道它相对于基地址的偏移。

要实现以结构体的方式访问寄存器，就要联系c语言对于结构体的定义（没搞懂，以后再来）
