# 基础及语法 Overview
 
```ccard
type: folder_brief_live
```
 
## 安装库
~~检查有没有pip, 没有的话使用`sudo python3 get-pip.py`指令~~
如果没有将pip加入变量, 使用`python -m pip install`, 有的话使用`pip install`即可
`pip install -i https://pypi.tuna.tsinghua.edu.cn/simple +包名称`一般是我最常使用的安装包方法，用清华镜像源
注: 如果使用了虚拟环境, 使用pip时可以用`pip -V`命令看一下自己的pip安装在了哪个虚拟环境
### 检修
如果有的时候无法直接安装, 可能是版本问题. 
使用`pip install -i https://pypi.tuna.tsinghua.edu.cn/simple 包名称版本号`, 不匹配就`pip uninstall`卸载, 再试试其他版本, 也许就成了
如果还是不行, 或者编译的时候出现了问题, 可以使用最后一条方法, 就是手动取安装对应的包
1. 下载后缀为 .whl的文件
2. 进入cmd 界面, 使用`pip install +文件的全称(包括后缀)` , 如果你有多个虚拟环境, 记得先切换进去
3. 切换特定虚拟环境: 
	1. 进入虚拟环境的Scripts目录
	2. 在cmd里运行activate.bat

## 日常使用一些注意事项
### 命名原则(强迫症)
#### 模块命名
（1）使用==小写==命名，
（2）除非有很多字母，==尽量不要用下划线==
因为很多模块文件存与模块名称一致的类，==模块采用小写，类采用首字母大写==，这样就能区分开模块和类。
#### 类命名
（1）类名使用==驼峰(CamelCase)命名风格==，首字母大写；
（2）私有类可用一个下划线开头。
#### 函数命名
（1）函数名一律==小写==，如有多个单词，用==下划线==隔开
（2）类内部函数命名，用单下划线_开头（该函数可被继承访问）
（3）不能使用数字开头！！！
#### 变量命令
（1）变量名推荐==小写==，如有多个单词，用==下划线==隔开
（2）类内部变量命名，用==单==下划线_开头（该变量==可被继承访问==）
（3）类内私有变量命名，用==双==下划线__开头(该变量==不可被继承访问==)
#### 常量
常量名==所有字母大写==，由==下划线==连接各个单词如MAX_OVERFLOW，TOTAL
#### 文件名
全小写,可使用下划线
## 数据类型
### 字符串
注意 py中的字符串不能修改
字符串字面值可以包含多行。 一种实现方式是使用三重引号：`"""..."""` 或 `'''...'''`。 字符串中将自动包括行结束符，但也可以在换行的地方添加一个 `\` 来避免此情况。
字符串可以用 `+` 合并（粘到一起），也可以用 `*` 重复
#### 索引和切片
 索引 （下标访问），第一个字符的索引是 0。单字符没有专用的类型，就是长度为一的字符串
 索引还支持负数，用负数索引时，从右边开始计数
索引用来获取单个字符，而 _切片_ 允许你获取子字符串:
注意，输出结果包==含切片开始，但不包含切片结束==。因此，`s[:i] + s[i:]` 总是等于 `s`：
#### 格式化
有几种方法
1. 类似于c语言(%d整数, %f浮点数, %s字符串, %x十六进制整数)
2. `format()`
3. 以f开头的字符串, 称之为f-string

### 列表
列表, 是用方括号标注, 逗号分隔的一组值。列表可以包含不同类型的元素
字符串（及其他内置 sequence 类型）一样，列表也支持索引和切片
列表还支持合并操作
注意 列表和字符串不同之处是列表可以更改其中的值
#### append()
在列表末尾添加新条目
#### 列表的特性
Python 中的简单赋值绝不会复制数据。 当你将一个列表赋值给一个变量时，该变量将引用 现有的列表。你通过一个变量对列表所做的任何更改都会被引用它的所有其他变量看到。
但是如果使用切片操作返回包含请求元素的新列表。
列表可以嵌套, 嵌套列表（创建包含其他列表的列表）

### Tuple
也是一个有序的列表, 但和上面list的区别是这个==一旦初始化就不能修改==
注意:  
1. 只有1个元素的tuple定义时必须加一个逗号`,`来消除歧义
2. tuple只是能实现指向不变, 但是如果指向的元素会变动, tuple也会被更改. 所以要实现一个内容也不变的tuple得保证其中的元素也不会变

### Dict
字典，查找速度极快
注意一个key只能对应一个value
#### 判断
可以通过关键字 `in`判断，eg` >>key' in dict`
或者可以使用`get()`方法, 如果没有的话会返回None
要删除的话, 可以使用`pop(key)`方法, 注意对应的value也会删除

### Set
这里是类似于dict, 这里是一个key的组合, 不包含value
注意, key不可以重复, 所以要创造一个set, 需要提供一个list作为输入集合, 但是传入重复元素也没有关系, 重复元素会自动过滤
#### 使用
可以使用`add(key)` 来添加元素
也可以通过 `remove(key)`来删除元素
#### 特殊用法
set可以看作是数学意义上的无序和无重复元素的集合, 所以两个set可以作为数学意义
```python 摘抄自网站
>>> s1 = set([1, 2, 3])
>>> s2 = set([2, 3, 4])
>>> s1 & s2
{2, 3}
>>> s1 | s2
{1, 2, 3, 4}
```


## 控制流
### while
while 语句用于在表达式保持为真的情况下重复地执行:
```python
while_stmt ::=  "while" assignment_expression ":" suite
                ["else" ":" suite]
```
这将重复地检验表达式，并且如果其值为真就执行第一个子句体；如果表达式值为假（这可能在第一次检验时就发生）则如果 else 子句体存在就会被执行并终止循环。

第一个子句体中的 break 语句在执行时将终止循环且不执行 else 子句体。 第一个子句体中的 continue 语句在执行时将跳过子句体中的剩余部分并返回检验表达式。
### match 语句
match 语句接受一个表达式并把它的值与一个或多个 case 块给出的一系列模式进行比较。这表面上像 C、Java 或 JavaScript（以及许多其他程序设计语言）中的 switch 语句，但其实它更像 Rust 或 Haskell 中的模式匹配。==只有第一个匹配的模式会被执行==，<u>并且它还可以提取值的组成部分（序列的元素或对象的属性）赋给变量</u>(解包赋值)。

最简单的形式是将一个主语值与一个或多个字面值进行比较：
```python
def http_error(status):
    match status:
        case 400:
            return "Bad request"
        case 404:
            return "Not found"
        case 418:
            return "I'm a teapot"
        case _:
            return "Something's wrong with the internet"
```
注意最后一个代码块：“变量名” _ 被作为 通配符 并必定会匹配成功。如果没有 case 匹配成功，则不会执行任何分支。

你可以用 | （“或”）将多个字面值组合到一个模式中：
```
case 401 | 403 | 404:
    return "Not allowed"
```

# 方法
## 编码相关
Python提供了`ord()`函数获取字符的整数表示, `chr()`函数把编码转换为对应的字符

Python对`bytes`类型的数据用带`b`前缀的单引号或双引号表示, 
以Unicode表示的`str`通过`encode()`方法可以编码为指定的`bytes`. 这里可以用于编码储存和传输.
日常读取的数据是`bytes`, 要把`bytes`变为`str`, 就需要用`decode()`方法.
注意:
>这里的str指的是显示出人可以直接识别出的文字, bytes表示一种以字节为单位的储存方式, 人不能直接识别, 用作计算机储存, 而编码方式是指str编码成bytes时候用的编码方式, 这些注意区分. 

纯英文的`str`可以用`ASCII`编码为`bytes`, 内容是一样的, 含有中文的`str`可以用`UTF-8`编码为`bytes`.

#### len()
对于str, `len()`函数可以计算字符数, 对于bytes的数据, `len()`函数计算字节数.

# 数据类型

## 补充
对于不变对象的研究
调用对象自身的任意方法，也不会改变该对象自身的内容。相反，这些方法会创建新的对象并返回，这样，就保证了不可变对象本身永远是不可变的。

关于python的endswith，可以匹配后缀，可以传入元组等匹配多个后缀
```python
def file_search(path):  
    filelist = []  
    switch = (".zip", ".rar", ".7z")  
    for root, dirs, files in os.walk("."):  
        for a in files:  
            if a.endswith(switch):  
                filelist.append(a)  
    print(filelist)
```