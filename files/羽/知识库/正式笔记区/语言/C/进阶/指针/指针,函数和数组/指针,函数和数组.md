# 指针,函数和数组 Overview
 
```ccard
type: folder_brief_live
```
 
~~如果想要编写一个处理一个数组的元素, 但是因为现阶段没办法在函数原型哪里表示数据类型, (c没有数组的数据类型, 而其他一些语言有 长这样`int[] float[]`) 所以就得用指针形式(因为数组实际上借助指针表达)~~ 有办法... 在函数原型处不仅仅可以用指针, 还可以使用类似`int arr[]`的方法声明, 注意这种办法`int arr[]`只能用于**声明形式参数**(即放在原型和定义的头部)!!!
![[Pasted image 20240122182424.png]]
c保证在给数组分配空间的时候, 指向数组后面的第一个位置的指针仍然是有效的指针, 是可以访问的... 

注意使用指针提取出的值`*p`进行改变的话是直接改变了p的值,
注意, 地址应该和指针类型兼容, 不能把double类型的地址赋向指向int的指针!
对指针而言 &运算符给出指针本身的地址

回顾 int字节4字节 32位(float也是4个字节)
注意 指针减去一个整数的时候 指针必须是第一个运算对象, 整数是第二个运算对象. 如果相减的结果超出了初始指针说指向数组的范围, 计算结果则是未定义的, 除非正好超过数组末尾仅1个位置, c保证该指针有效. 
![[Pasted image 20240122182442.png]]注意 指针的减法有两种, 可以用一个指针家去另一个指针得到一个整数, 或者用一个指针减去一个整数得到另一个指针

不要应用未初始化的指针!!!
```
int * pt; //这是未初始化的指针
*pt = 5; //严重的错误
```
pt不是普通的数值, 是一个随机的地址, 不保证其中有什么东西, 可能是空的, 也有可能是关键数据.如果进行擦写的话, 很容易造成不可预计的问题
在使用指针之前, 必须先用已知道的已分配的地址初始化它!

没有指针相加 更也没有指针相乘, 相除! 

##### const 只能调用不能修改
**注意 这一节要重看! 迷迷糊糊的**p301页, 阅读器321页


#为什么需要指针
对于单个数据, 可以使用指针或者数值的方法传入函数. 但是对于数组, 大部分情况都只能使用指针传入. 因为这样效率高, 不必再分配空间来进行储存和进行拷贝 但是很容易误伤到原数值
故引入 const
const不仅可以用来创建变量
`const double PI = 3.1415`
还可以创建指针, 数组
甚至可以放在形参中
![[Pasted image 20240122182511.png]]
const限定了什么只是限定了通过那种方法访问修改, 可以使用其他方法进行访问修改. 但是可以调用, 如下面的例子, `pd++`可以使用
```c
double rate[2] = {7.0, 8.0};
const double *pd = rate;
pd[0] = 1.0;   //不行
*pd = 1.0;     //不行
rate[0] = 0.0; //可以
```
const 定义的指针只是不能通过该指针去改变对应地址的值也不能导出对应地址, 但是可以改变该指针指向的对象
const就是相当于封锁了通过该指针进行修改对应地址的路, const相当于给指针一个属性, 封锁了各种方法, 甚至不能提取出地址, 东西只进不外传...可以去修改该指针的对应地址, 改变该指针对应的内存(你可以改变我的效忠对象, 但是自此至终你都不能得到原效忠对象的信息, 你也对它做不了什么😀)