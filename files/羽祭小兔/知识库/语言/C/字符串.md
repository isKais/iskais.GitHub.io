## 字符串
数组和指针的区别
一个是初始化字符数组来储存字符串，另一个是初始化指针来指向字符串！
### 相同之处
- 两个都可以使用数组表示法
- 两个都可以进行指针加法
### 不同之处
只有指针表示法才可以进行递减操作
### 注意
可以使用这样的形式让指针指向数组 即`指针名 = 数组名`, 不能反过来, 因为赋值的左侧是变量(即是可修改的左值), 指针可以修改指向的方向, 但是数组不可修改代表数组的名字所指向的地址(另一种说法, 数组元素是变量, 但是数组名不是变量).
![[Pasted image 20221025184824.png]]
## 字符串输入
### 首先 分配空间
计算机不会进行自动分配空间, 所以要自己来, 不然的话数据会溢出, 误擦写掉程序中的数据和代码
使用`char name[10]`来进行分配空间
### gets函数和puts函数
gets()这个函数负责读取整行输入, 遇到换行符截至, 然后**丢弃换行符**
puts()这个函数负责显示字符串, 并在末尾添加换行符
### 使用
```
char words[10];
gets(words);
puts(words);
puts("xxoo")
```
#### gets函数的问题
由于该函数唯一的参数是其中的数组名, 所以它我发检查数组是否装的下输入行, 总而言之 就是gets函数只知道数组的开始出来进行写入, 这就容易导致缓冲区溢出, 即多余的字符超出了指定的目标空间, 然后可能擦写了重要数据, 会导致gg
缓冲区溢出程序会提示`segmentation fault`(分段错误), 说明程序正在识图访问未分配的内存.
**现在gets正在逐渐被移除, 有些编译器已经不支持了, 所以建议别用这个函数**
### fgets函数和fputs函数
增加了一个参数来限制读入的字符数量...
- fgets()函数的第二个参数指明了读入字符的最大数量. 如果该参数的值是n, 那么最多读取n-1个(类似数组 其大小是n-1), 或者读取到第一个换行符为止
- 注意fgets不会丢弃换行符, 它读取到换行符之后会将它储存在字符串中!
- 它有第三个参数, 第三个参数指明要读入的文件, 如果读入从键盘输入的数据, 则以stdin(标准输入作为参数)
- 输出的fput则有两个参数, 第一个是变量, 第二个是`stdout`
### 使用
```
fgets(words, num, stdin);
fputs(words, stdout);
```
注意使用fputs输出的话,不会在字符串末尾添加一个换行符号, 但是puts()会添加
两对函数的区别, 一个(无f的)先丢弃在添加换行符, (有f的)不丢弃不添加
fgets的返回值是地址, 字符串写入的地址. get也是同理

如果读取到末尾, fgets会返回NULL(也就是空指针)
### gets_s函数
gets_s只从标准输入中读取数据, 所以不需要第三个参数(类似于fgets的lite版本)
如果函数读取到换行符, 会丢弃它(不想fget, 更偏向于gets)
如果gets_s函数读取到了超过限制的字符数量, 就会丢弃之后的输入, 直到读取到换行符号或者EOF文件结尾, 然后丢弃它... 最后返回空指针NULL(描述不一定对?)
![[Pasted image 20221026204805.png]]
### 补充
为什么需要丢弃过长输入行中的余下字符, 这是因为输入行中多出来的字符会留在缓冲区中, 成为下一次读取语句的输入, 如果吓一跳读取语句和程序不符合就会崩溃...gg

### scanf函数的补充
scanf函数遇到空格或者末尾就结束本次读取. 虽然读取字符串不太便捷, 但是可以在读取并转换混合数据类型为某种标准形式上发挥作用, 这也是典型用法
scanf如果输入行的内容过长, 也会导致数据溢出, 但是可以使用字符宽度来限制

## 字符串输出
有三个标准库 puts fput printf
puts函数只需要把地址作为参数传递给它即可, 注意会自动在其末尾添加一个换行符
注意啊!!! 该函数只有在遇到空字符的时候才会停止输出, 所以必须确保有空字符!!!直接的字符串编译器会提供空字符, 但是输入或者数组的话就不一定了 所以 必须确保有空字符!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
不然就会一直打印字符串后面内存中的内容, 直到遇见空字符.
#### fput
带有f的函数是专门针对文件定制的版本(或者说是多功能的plus版)
前面已经写了, 但是顺手还写一下把
fput不会再输出的末尾添加换行符
然后fput的第二个参数表明要写入数据的文件, 如果要打印在显示器上, 可以用stdout(标准输出)
(联系重定向输入doge)

---------
提示! NULL指向空指针,  而空指针的值是0
所以 NULL可以作为 0参与判断
也就是
`while (gets(line)) 与 while(gets(lin) != NULL)相同的原因`

----------------
注意使用有f的和有f的配对使用不要混用, 避免多个换行符
### printf
主要是作为格式化输出, 与put的区别, 这个不会自动再每个字符串末尾加上一个换行符, 所以要自己来

字符串参数长这样 `const char*string`, 也可以这样`const char string[]`
### 补充
做字符串测试的时候, 有一种写法可以使用
即:
`while (*string) //string是字符串数组的表示`
当string指向空字符的时候, ``*string``的值是0, 即初始条件为假, while循环结束
## 字符串函数
### strlen函数
字符串的长度, 空格以及符号算数
(?)c字符串常量的串联特性
### strcat函数
用于拼接字符串, 这个函数接受两个字符串作为参数, 然后把第二个字符串的备份附加在第一个字符串末尾, 并把拼接后形成的新制服串作为第一个字符串, 第二个字符串不变
这个strcat函数的类型是char* 所以返回的是一个地址, 也是第一个参数(即拼接后的)的地址
### strncat函数
这个是上面的函数的升级版
因为上面的函数可能会导致溢出, 第一个数组可能会被第二个字符串撑爆
所以使用strncat, 该函数的第三个参数指定了最大添加字符数
### strcmp函数
在c里面, 如果直接进行字符串比较的话比较的是地址, 是比较不了的
但是如果使用`*`字符来提取地址的值的话提取出来的是第一个字符的值
貌似没办法在程序中直接使用整个字符串
所以要比较的话就要使用 strcmp函数
strcmp函数第一个参数为第一个字符串, 第二个参数为第二个字符串 ~~这不是废话吗~~
返回值是一个数字, 如果两个字符串相等, 返回0, 不相等 返回一个非0值(非相同即真)
注意, 这个函数比较的是所有的字符 而不是仅仅比较字母
这个函数比较的是字符串本身, 不是比较一整个数列, 所以效率高一点....
关于返回值 有点奇怪, 以后再研究吧
### strncmp函数
这个是上面的改良版 无力吐槽了
这个可以比较到字符不同的地方, 也可以只比较
就是说 上面那个是全局匹配(整个字符串匹配的), 这个是可以全局匹配(第三个参数不选), 第三个参数可以指定要查找的字符数, 查找到了就会返回 0
`strcmp("abs","absds") //不相同`
`strcmp("abs","absds",3) //相同`
### strcpy和strncpy函数
上文说到 `貌似没办法在程序中直接使用整个字符串,用*提取的话也只是第一个字符` 所以要使用特殊的函数来拷贝字符串到另外一个地方
如果直接相等的话, 拷贝的只是字符串的地址
注意 第一个是目标字符串 第二个是源字符串

返回值 返回的是char指针类型, 是第一个参数即第一个字符的地址
小技巧 第一个参数不必指向数组的开始, 这个属性可用于拷贝数组的一部分

# 字符串的其他
## 字符串转换为数字
有特殊的函数可以将字符串转换为数字 
就是 atoi()这个函数 字面意思
但是如果输入的是纯字符怎么办? 这个会返回 0(注意这种情况是未定义的, 有危险, 所以用下面的函数比较好-->strtol() )
但是如果输入的是数字混合字符怎么办? 这个函数只把开头的整数转换为字符
### 类似的函数
类似的有
- atof() 转换为double类型
- atol() 转换为long类型
更智能的函数(可以识别和报告字符串中的首字符是否是数字)
- strtol()
- strtoul()
- strtod()
![[Pasted image 20221104205659.png]]
