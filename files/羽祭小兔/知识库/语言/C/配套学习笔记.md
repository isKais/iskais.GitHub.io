# 错误

不能 void main(void),main 必须返回 int!正确写法 int main(void).但是注意除了main函数需要返回int的外,其他函数可以返回void

c语言中''和""是不一样的,不要用错地方!

 error: ambiguating new declaration of 改动了函数的返回值输入输入值啥的,不要单只改动代码,在声明处也要改!!!!

不单单在main函数中,在其他函数中如果没有return的话,默认程序运行到最外面花括号的时候会返回0
sizeof 查看数据类型所占用的空间
strlen 查看字符串长度(字节数)

### for循环
for循环有三个表达式, 
1. 第一个表达式是初始化, 只会在for循环开始的时候执行一次. (这里也不一定要int a = 0啥的, 可以开阔思维, 放电其他合法的表达式 ,但是这个表达式只在初始的时候运行一次)
2. 第二个是测试条件, 在执行循环的之前对表达式求值. 如果表达式为真(也不一定要比大小啥的, 但是需要式判断式!)
3. 第三个为更新语句(注意, 不一定要i++, 它这里可以使用任何合法的表达式. 无论是什么表达式, 每次迭代都会更新该表达式的值)<----注意这个语句在for循环的最后更新, 也就是运行完for里面的语句块之后 之后进行运行.

如果需要暂停程序的话可以使用

include<stdlib.h>

然后使用这个system("pause");



然后关于scanf的问题,这个输入的话不是运行一次就弹出一个输入的框,而是在第一次输入的时候弹出这个输入端口,然后用户进行输入缓存,输入完毕的话(即按下回车(?)),scanf进行将缓存载入一次(或多次的)符合输入的值, 如果缓存中的值全部载入的话,缓存销毁(吧),如果值太多,缓存将会存留,等到下次再调用scanf的时候从缓存读取(下次就不会弹出输入的框了).直到全部读取完毕...scanf返回的值是其中单个函数中读取到的值...

补充,关于scanf  如果读取到与参数规定不同的值,scanf会停止读取,并把值原封不动的还回缓存.并且将那个值本要对应的变量设为0(就是设为0),等到下个符合参数的值来对应时候,才会从缓存中取出这个值,如果一直没有对应参数的值的话,这个值就会一直卡在缓存中



两个就偷懒 doge

**当&运算符两侧的表达式的结果均为真时，整个运算结果才为真。
当&&操作符第一个表达式为 false时，结果为 false，并且不再计算(这个计算不仅仅是计算,还是运行!然后注意,就是非0即1,只要不是直接返回0,结果都是true)第二个表达式。**

|和||同理





在C语言中，&有三种作用，分别如下：

\1. 取地址。单目运算符。用来取一个变量的地址。

比如

int i, *p;
p = &i;//这里的&作用是取变量i的地址。

\2. 位操作中的与操作运算符。

也就是常说的and操作，双目运算符。

计算的时候按位计算，&两边操作数对应位上全为1时，结果的该位值为1。否则该位值为0

比如

0x12&0x23 转为二进制为:

B00010010&B00100011，

按位计算结果为B00000010，

即结果为0x02。



\3. 当两个&&一起用的时候，表示为逻辑运算中的与运算。

逻辑运算结果只有0和1两种结果。

一般在&&两边是两个逻辑表达式。

当两个表达式值均为1时，&&运算结果为1，否则为0。

比如

2>1 && 0<1 这个的值为1&&1 = 1。

1>2 && 2>0 这个值为0&&1 = 0。

1>2 && 2>3 这个值为0&&0=0。



旁边两个人谈论的问题,待会思考下,就是break能不能终止if,我个人呢倾向于是可以终止的

注意优先级,就是

**[C语言](http://lib.csdn.net/base/c)运算符优先级**

 {因为c先计算那一部分是不确定的,c把先计算那一部分的决定权留给编译器的设计者,以便对特定系统的优化设计, 但是对于逻辑运算符是个例外,c保证逻辑运算符(三个:&& || !)的求值顺序是从左往右}
![[9e0f4b472550aafddd3a876bfc5ebb2ab251fe7f.png@942w_257h_progressive.webp]]![[fd71a6515fe78b2495a4dede8a09d2c870d7c9c1.png@942w_425h_progressive.webp]]![[4f770701104476c7fe5ee6fbfb10fd6d6adc893a.png@942w_339h_progressive.webp]]![[2363baac3ae374b9b5a61ff9b9bb5277317d9d82.png@942w_546h_progressive.webp]]![[c2ea0a7824b2908e7261741e4ff14fe8683ad286.png@942w_581h_progressive.webp]]

**说明：**

  **同一优先级的运算符，运算次序由结合方向所决定。
  简单记就是：！ > 算术运算符(加减乘除取余) > 关系运算符(大于小于等于...) > && > || > 赋值运算符**


getchar()读取每个字符,包括空格,制表符,换行符.但是scanf()读取数字的时候会跳过空格,制表符,和换行符!

输入有字符组成,大师scanf可以把输入转换陈整数值和浮点数值.使用转换说明(如%d或%f)限制了可接受输入的字符类型, 而getchar()和使用了%c的scanf()接受所有字符

#### 函数
在程序中三次出现
- 函数原型(告诉编译器函数的类型)<--可以放在主调函数的里面...
- 函数调用(表明在此执行函数)
- 函数定义(明确制定了函数的功能)<--这里不需要分号,但是前面两次需要
##### 分步讲解
在函数原型这里,但函数接受参数的时候, 函数原型用逗号分隔的列表指明参数的数量和类型, 但是也可以省略变量名(就离谱)<--注意, 函数原型这里才可以省略变量名字!!! 在函数定义这里省略会报错!!!`编译器提示"存在正文时不允许未命名的原型参数C/C++"`
##### 地址类型省略是长这样 
`void int(int *, int *)*`
函数调用这里, 被调函数的值是从主调函数中拷贝而来, 独立的
不要混淆函数声明和定义. 函数声明告诉编译器函数的类型, 而函数定义则提供实际的代码

![[Pasted image 20221014114844.png]]


### 递归
递归在处理倒序的时候非常方便! 但是一般情况下使用循环更好

`undefined reference to xxx collect2.exe: error: ld returned 1 exit status`
错误出现在没有引用头文件，或者声明的函数体与调用的函数不一致导致。或者在编译的时候没有链接全代码

虽然不会报错, 但请养成return的习惯, return返回需要有返回值如果定义了的话, 没有在函数原型哪里定义才不需要啊, 请不要无视定义啊

main()也可以被自己或其他函数递归调用

### 指针
#指针
![[Pasted image 20221014160630.png]]
通过 `int * num`定义了后, num的值就变成了一个地址(我称它为int型地址), 没有对应之前是初始值 
&num 也是一串十六进制的地址
地址实际上就是一串十六进制的数字,  然后使用`*num` 就会导到实际的地址上的值
`*num`实际上就是一个变量, 它可以作为左值也可以作为右值(关于左值右值:左值是可以修改的)
一点小想法[doge]
```
int * b; //创建一个空容器

b = &a;  //提取出a的核心也就是地址, 塞入b容器, b就等于地址了

putchar(*b); //*b后 从b的地址找到a的本体, 然后可以肆意操控了, *b就相当于a
```

如果要在被调函数中改变主调函数的变量, 就要使用指针
![[Pasted image 20221014162940.png]]
看上图, 机器地址指向的空间大小不是全部都是一样的, 而是大小可以不一样的, 电脑用地址给每一块东西(注意是每一块)都做了个导向 地址对应的不是每个字节, 我更倾向于是对应于每个元素!


### 数组
c语言中没有专门用于储存字符串的变量类型, 字符串都被储存在char类型的数组中!
如果不初始化数组，数组元素和未初始化的普通变量一样，其中储存的是垃圾值；但是，如果部分初始化数组，剩余的元素就会被初始化为0。

注意：
- 如果初始化数组是省略方括号的数字，编译器会根据初始化列表中的像素来决定数组的大小。
- `sizeof 数组`返回的是整个数组的大小(以字节为单位); `sizeof 数组[0]`返回的是数组中一个元素的大小(还是以字节为单位). 整个数组的大小初一单个元素的大小就是数组元素的个数

#### 指定初始化器
重点在于**指定**
![[Pasted image 20221016195409.png]]
指定初始化器的两个重要特性
##### 特性
1. 如果指定初始化器后面有更多的值, 如该例中的初始化列表中的片段`[4]=2, 3, 3` 那么后面这些值将会被用于初始化指定元素后面的元素
2. 如果在此初始化指定的元素, 那么后面的初始化将会取代之前的初始化
3. 指定初始化器可以特定指定某一个值是多少, 在单独指定的时候非常有用.  如果有指定的话(即使是单个值), 其他的值不会是未指定之前的垃圾值, 而是会变为0
4. 如果未指定元素大小, 又使用了指定初始化值的时候, 编译器会把数组的大小设置为足够装的下初始化的值. 

#### 重点
- c不允许吧数组作为一个单元付给另一个数组
- 除了初始化以外不允许使用花括号列表的形式赋值(也即是只能使用单个单个赋值)
- 最好在声明数组的时候使用符号常量来表示数组的大小
- 数组大小必须为整数
- 

##### 数组下标越界
c编译器会正确通过语法检查运行, 但是值会出现问题(会变成什么值我也不清楚)
#### 二维数组

![[Pasted image 20221020163210.png]]
rain 是数组类型的数组  `rain[2]`说明是提取出rain数组类型的数组中的第二个数组, `rain[2][1]`数组中的数组的第一个元素
定义除了可以使用大花括号包围小花括号, 还可以使用 省略内部的花括号, 只保留最外面的一对花括号, 只要保持初始化的数值个数正确. 但是如果初始化的数字不够, 则按照先后顺序进行初始化, 直到用完所有的数值.后面没有值初始化的元素统一初始化为0

#### 其他维度数组
如果要使用更多维度的数组, 可以继续叠加 类似这样`int box[10][5][10]...`

### 指针和数组
系统中, 地址按字节编排. (short占用2个字节 int占用4个字节 double占用8个字节)
指针加一是指增加一个储存单元. 对数组而言 这意味着
**加一后的地址是下一个元素的地址, 而不是下一个字节的地址!!!**
![[Pasted image 20221020165826.png]]
要声明指针所指向的对象类型, 指针储存的是一个元素头部字节的地址(这是在一个较大对象的时候才储存该对象第一个字节的地址, char就不是, 这不是废话嘛doge), 就是有定义了对象类型, 这样才能正确知道要取多少字节来返回, *pt才能取出正确的数值

**指针加一, 执政的值递增它所指向的类型大小(以字节为单位)**
![[Pasted image 20221020170941.png]]
所以 反过来可以使用数组表示指针......
(我的理解)`数据类型 名字[序号]`, `名字`里储存着数组的第一个元素地址, `序号`代表着是这个第一个元素地址的后面第几个, `[]`可以理解为 `*`符号, 来提取元素的值...这样子也就解释通了为什么数组的第一位提取要使用`名字[0]`来提取 等同于`*(第一位元素地址+序号值0)`, 因为0这是当前第一位元素, 所以加1就是第二位, 加2就是第三位... 来源于指针

在数组中, 名字就是地址!

`ar[i]`和`*(ar+i)`相等!
##### 函数 数组和指针
~~如果想要编写一个处理一个数组的元素, 但是因为现阶段没办法在函数原型哪里表示数据类型, (c没有数组的数据类型, 而其他一些语言有 长这样`int[] float[]`) 所以就得用指针形式(因为数组实际上借助指针表达)~~ 有办法... 在函数原型处不仅仅可以用指针, 还可以使用类似`int arr[]`的方法声明, 注意这种办法`int arr[]`只能用于**声明形式参数**(即放在原型和定义的头部)!!!
![[Pasted image 20221020185800.png]]


c保证在给数组分配空间的时候, 指向数组后面的第一个位置的指针仍然是有效的指针, 是可以访问的... 

注意使用指针提取出的值`*p`进行改变的话是直接改变了p的值,
注意, 地址应该和指针类型兼容, 不能把double类型的地址赋向指向int的指针!
对指针而言 &运算符给出指针本身的地址

回顾 int字节4字节 32位(float也是4个字节)
注意 指针减去一个整数的时候 指针必须是第一个运算对象, 整数是第二个运算对象. 如果相减的结果超出了初始指针说指向数组的范围, 计算结果则是未定义的, 除非正好超过数组末尾仅1个位置, c保证该指针有效. 
![[Pasted image 20221020201246.png]]
注意 指针的减法有两种, 可以用一个指针家去另一个指针得到一个整数, 或者用一个指针减去一个整数得到另一个指针

不要应用未初始化的指针!!!
```
int * pt; //这是未初始化的指针
*pt = 5; //严重的错误
```
pt不是普通的数值, 是一个随机的地址, 不保证其中有什么东西, 可能是空的, 也有可能是关键数据.如果进行擦写的话, 很容易造成不可预计的问题
在使用指针之前, 必须先用已知道的已分配的地址初始化它!

没有指针相加 更也没有指针相乘, 相除! 

##### const 只能调用不能修改
**注意 这一节要重看! 迷迷糊糊的**p301页, 阅读器321页

#为什么需要指针
对于单个数据, 可以使用指针或者数值的方法传入函数. 但是对于数组, 大部分情况都只能使用指针传入. 因为这样效率高, 不必再分配空间来进行储存和进行拷贝 但是很容易误伤到原数值
故引入 const
const不仅可以用来创建变量
`const double PI = 3.1415`
还可以创建指针, 数组
甚至可以放在形参中
![[Pasted image 20221020205331.png]]
const限定了什么只是限定了通过那种方法访问修改, 可以使用其他方法进行访问修改. 但是可以调用, 如下面的例子, `pd++`可以使用
```c
double rate[2] = {7.0, 8.0};
const double *pd = rate;
pd[0] = 1.0;   //不行
*pd = 1.0;     //不行
rate[0] = 0.0; //可以
```
const 定义的指针只是不能通过该指针去改变对应地址的值也不能导出对应地址, 但是可以改变该指针指向的对象
const就是相当于封锁了通过该指针进行修改对应地址的路, const相当于给指针一个属性, 封锁了各种方法, 甚至不能提取出地址, 东西只进不外传...可以去修改该指针的对应地址, 改变该指针对应的内存(你可以改变我的效忠对象, 但是自此至终你都不能得到原效忠对象的信息, 你也对它做不了什么😀)

#### 指针和多维数组

zippo数组长这样 {{int, int}, {int, int}}
zippo地址是第一个数组的地址,所以zippo是一个指向占用两个int大小对象的地址
而第一个数组的地址是第一个int, 所以zippo和zippo[0]相同

注意计算机中的地址是按照字节编排的, 字节+1, 地址+1
而区分不同元素靠的是数据类型, 来划分区块.
而不是每一个元素对应一个地址, 是每一个地址对应一个字节, 然后通过对应的数据类型, 划分不同的区块来对应元素!!

`地址+数字`表示的是下面元素的值, 不是下面字节的值

要懂得变通, 如果程序使用一个指向二位数组的指针, 而且要通过该指针获取值的时候, 最好用简单的数组表示发, 而不是复杂的数组表示法

##### 指向多维数组的指针
如果我不想指针指向多维数组的其中一个数组的第一个值, 我想要指向多维数组的其中一个数组.
就需要使用别的定义法
![[Pasted image 20221021115011.png]]

--------------------------

警告: 之前关于指针和多维数组的理解不一定正确!!! 小心使用, 以后再来统一整理
下面是最新的理解
由于是多维数组 有特别的地方
```
int main(void)
{
    char zip[2][2] = {{1, 2}, {3, 4}};

    re_pri(&zip[0][0]);

    re_pri(&zip[0][1]);

    re_pri(&zip[1][0]);

    re_pri(&zip[1][1]);

    printf("%p\n", zip); // 在这里zip作为这个二维数组的代称,系统中使用数组第一个数组中第一个的值的地址作为代称

    printf("%p\n", zip+0); // 不变

    printf("%p\n", zip+1); // 是数组第二个数组中第一个的值的地址

    printf("%p\n", *zip); // 是数组第一个数组中第一个的值的地址(在这里zip作为这个二维数组的代称,对其*会返回其里面包含的值,也就是数组第一个数组中第一个的值的地址)

    printf("%p\n", **zip); // 是具体的值(在这里zip作为这个二维数组的代称,对其*会返回其里面包含的值,也就是数组第一个数组中第一个的值的地址,再进行*的话就会返回具体的值)

    printf("%p\n", &zip); //是数组第一个数组中第一个的值的地址(在这里zip作为这个二维数组的代称,对其&会返回表示会这个数组的地址也就是第一个数组第一个值的地址)
}
```

---------------------------
##### 变长数组
变长数组可以定义在函数的形参中, 
如果不想在前面给出变量, 使用`*`
`int sum(int, int, int ar[*][*])`

### 字符串
#### puts函数
puts()函数只显示字符串, 并且自动在字符串后面加上换行符, 总而言之这是一个专注于字符串输出的函数.
可以直接使用 `puts("这里是字符串")`
字符串末尾会被编译器自动加入`\0`
用双引号括起来的是字符串常量, 也叫字符串字面量
注意:
1. 如果字符串常量之间没有间隔, 或者用空白字符隔开, 编译器会视为一个字符串常量
`"this" "aaaaaaa""我是" = "thisaaaaaaaa我是"`
2. 如果要在字符串中使用"的话, 使用`\"

字符串
"这里是字符串"其实是一个指针 直接使用%P打印出来的话就是一串地址
而字符串 究其根源是一个随用随弃的char数组, 它没有自己的名字(也不需要), 调用它的唯一方法就是在创建的时候使用其本身
字符串我认为应该是长这样
`{'t', 'h', 'i', 's', '\0'}` 所以可以使用下面的方法定义字符串数组, 亦可以使用下面的方法%p和`*"字符串"`

字符串使用char数组作为储存方式, 所以%p打出的地址就是字符串第一位字符的地址, 但此时该地址也表示整个字符串, 如果使用`*"字符串"`

捂脸 可以使用这种办法
#定义字符串数组
`char ml[40] = "这里是字符串啊啊啊"`这是由于字符串实际上就是一个数组的一半结构

在初始化数组的时候, 没有用到的地方都会被初始化为`\0`
但是可以让编译器自己计算数组的大小, 也就是省略初始化声明中的大小(原理是查找字符串末尾的空字符)

![[Pasted image 20221023110503.png]]
##### 使用数组形式和指针形式定义字符串的不同
首先明确一个概念
程序运行的时候先把程序拷进去内存, 这时候程序位于内存中的静态储存区待命, 运行哪一些代码的时候就把程序拿出来运行
如果使用数组形式定义字符串, 原先字符串是放置在静态储存区, 在运行区创建了个数组, 然后把字符串从静态储存区拷入运行区的数组, 这才完成了定义
如果使用指针形式, 初始化指针只是把字符串的地址拷贝给指针, 指针能直接调用位于静态储存区的字符串
总而言之 就类似于上面的
#为什么需要指针 这里描述的东西, 这两个类似, 字符串也是一个指针
注意: 使用数组形式定义的字符串, 它的数组名是一个常量地址, 这个地址是该字符串的代称
