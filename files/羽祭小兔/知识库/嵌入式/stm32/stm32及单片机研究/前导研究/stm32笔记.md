## 前导
### 介绍
1. arm内核 32位单片机 stm32（51是8位的）
2. mcu 是微控制器 即单片机
3. 基于arm内核-cpu
4. st-link是一个仿真器，负责烧录调试。
Keil 搭配 STM32CubeMX 。STM32CubeMX用来配置外设引脚及参数， 并生成C 初始化代码，之后在Keil中无需再配置外设及参数，直接编写应用程序即可。

stm32名称介绍
f---代表基础型
103---代表基础型
c---48pin
6---128kb
t---qfp封装
6---使用温度

手里这块是stm32f103c6
官方界面：https://www.keil.com/dd2/stmicroelectronics/stm32f103c6/
手上这个有够丐的（10kbram 32kbrom）

#### stm32cubeide
不得不说 官方的软件就是好用 环境配置的稳稳当当
安装驱动全自动 只需要选择你想要的开发板类型 东西就好了
然后我得继续研究下
插入st-link自动连接 简直牛逼 还能自动检测st-link的版本 进行自动更新
太离谱了, 我绝对不跟别人说 
遇到一个问题
要进行st-link更新的话 就不能在连接stm32的时候更新
连接的时候进不去更新模式 也就是dfu模式
所以要把线拔出来
嗯 环境就配置好了

#### keli配置
下载好了就安装
然后打开
https://www.keil.com/dd2/pack/
下载对应的包(开发工具)
https://zhuanlan.zhihu.com/p/145801160

#### 重要文件
| 文件                   | 描述                                                         |
| ---------------------- | ------------------------------------------------------------ |
| stm32f10x.h            | 这个用于存放寄存器映射的代码，这些都是前面加的头文件里定义封装好的结构体,也就是这里的 |
| main.c                 | 用于存放用户的main函数                                       |
| startup_stm32f10x_hd.s | 这是启动文件 由官方提供 从固件库中拷贝而来，是系统上电运行的第一个程序 由汇编语言编写 |

#### 开发方式
有两种
一种是基于寄存器的方式
另一种是基于hal库的方式

#### 注意事项
固件库中启动文件有很多种类型
要自己选择合适的启动文件！
配置环境首先配置keil，这是最基本的，不要想着配点别的，会耽误非常多时间！！！
而且对于各个文件了解不透，难以配置其他的环境。
keil是专门开发好的，特别是进行标准库开发，非常方便配置。
如果使用其他的需要迁移标准库，非常非常麻烦，之前就是耽误了非常多时间在这里！！！

## 学习路径
1. 模电数电
2. 微机原理
3. 安装完STM32学习的软件
4. 挑选部分例程的HEX
5. https://www.st.com/content/st_com/zh.html
6. https://www.stmcu.com.cn/
7. 官方文档《参考手册》，《STM32固件库使用手册》选读，但是前几章必读。存储器和总线架构、电源控制、备份寄存器、复位和时钟控制，通用和复用功能I/O，中断和时间等等前几章一定要花时间阅读。
8. 熟悉调试软件
9. gpio编程

## 预备研究
### 开发环境
Keil5
STM32CubeIDE
CLion
RT-Thread Studio
vscode+platformio
### stlink
这东西是一个仿真器
它可以使用
调试和烧录的功能
(我手上的是山寨的烧录 没想到我家里也还有一个...我家里的nfc烧录器用的也是stm 回去有时间看看)
里面可能还有个stm 
而且st-link可以升级
### 启动文件
作用是初始化整个stm32
功能就不提了
重点关注于如何从启动文件到main程序文件
流程
1. 调用systeminit()函数配置stm32的系统时钟
2. 设置c库的分支入口`"_main"`(最终用来调用main函数)
相关联的启动文件中的程序
`reset_Handler`
研究该程序 说明systeminit()和_main在别的地方
也就是说 systeminit()这里需要我们来实现, 需要编写一个具有该名称的函数, 用来初始化stm32的时钟(固件库中已经有了)
而_main是c库, 在这个函数末尾会调用我们写的mian函数

综上所述
我们需要
1. systeminit()
2. main()

### stm32f10x.h文件研究
![[Pasted image 20221119100414.png]]

### 项目文件研究
对于一个项目有
启动文件---官方汇编文件用于启动时候运行 相当于电脑的boot
寄存器相关的文件(我不知道是什么正式名字)---这个将stm32内的个个外设的地址封装到结构体中, 然后让二进制的地址有了名字 方便调用, 这里是最基础的地方 一切都在这里开始 我们可以简单的使用寄存器来操控一些东西 要实时查阅stm32的参考手册来编写代码 但还是太过于繁琐 所以便进行了更进一步封装 形成了库
标准库---这里存放着标准库, 这里是更进一步的抽象 

在src文件中
misc是内核的库函数 其他的是内核外设的库函数

在inc文件中
里面是库函数的头文件

有conf文件是用来配置库函数头文件的包含关系的, 是所有库函数都必要的
然后两个it文件是用来存放中断函数的
这些都是必须的
放在user

要使用标准外设库的话还要在工程选项-c/c++哪里的define写入`USE_STDPERIPH_DRIVER`这样才能使用标准外设库

### 总体构建

#### 概述

代码从抽象到具体，一块芯片（stm32）包括有外设和内设，我们平时通过代码来操控外设以实现控制芯片外的设备，要访问外设就得需要知道外设的地方，外设通过地址来确定位置。stm32地址有特定的数量，每个地址区段对应不同的外设或者内设，某一段地址是一个总线，总线下有具体的外设。

最基本的操作就是直接操作对应的地址，在此基础上，可以通过操作端口配置寄存器来设置

由于操作寄存器过于复杂，在此基础上便出现了库函数，通过库函数可以不用直接和寄存器打交道，直接操作端口

#### 是如何包装的呢？

我们可以从上面知道，这些外设是有各自的地址的，stm32的外设共同排布在4g的空间内（小注：因为stm32是32位芯片，所以地址只有4gb的大小，如果是电脑的64位会有更大的地址。这也是为什么xp等32位系统最大只能支持4gb内存的原因，因为32位最大只能包含4gb的地址。）

在stm32的4gb地址空间内，有8个块，各自负责不同的功能。其中最重要的是有3个

- block0 内部flash，这里放着编写好的程序代码，内核通过icode总线来取里面的指令来运行。注意这里不仅仅有自己编写的代码，还有硬件运行的基础代码，例如看门狗啥的。
- block1 内部ram，程序的变量、堆栈等（注意这里不是代码占用空间，是代码运行的时候花费的空间。为什么会多出空间呢？代码运行的时候例如用户输入或者for循环都会花费空间）
- block2 片上外设，负责外设的地址。这里有两个大类，分别是apb和ahb两个部分，其中apb又有apb1和apb2两个部分，我记得apb2和ahb是高速外设，apb1是低速外设

知道了地址空间的划分，就要研究具体外设了。就比如最基本的gpio外设，它是从0x40010800开始的，这个0x40010800是gpio外设的基地址。

明白了基地址的定义，就能理解寄存器上地址偏移的意思，这个意思是相对于基地址往后偏移多少位。

gpio操作是通过寄存器来操作（注意我们不能直接操作具体的引脚，~~这要是能操作未免太奇怪了吧~~，所以在gpio的地址里，不是具体的引脚的地址，里面是寄存器的地址，我们通过操作寄存器来操作引脚），gpio有很多种寄存器（负责同一批端口都有不同的寄存器），这些寄存器方便操作对应的引脚。寄存器编程就是通过操控这些寄存器来操作引脚的。

而库函数就是把一堆寄存器组合起来操作。

------

上面的描述是理解基本的包装，下面是继续理解具体包装的过程（当然是通过c语言角度）。

众所周知，我们有很多很多的地址，地址是一串数字，是反人类的（doge）。我们当然不方便来直接通过一串数字来操作吧，所以要进行数字和变量对应，通过预定义`#define 变量 具体的地址`

插一嘴，这里就是stm32f10x.h文件的作用，叫做寄存器映射。~~嗯，思路有点断了差评~~

外设有这么多，总体有4gb这么多，虽然我们不必要定义所有的外设，但是单单gpio的地址就要好多好多个了，那怎么办，联系上面的地址偏移。

我们先定义基地址，在定义具体的片段的基地址，再再定义片段的片段的基地址。这样我们就能很好的找到想要的寄存器了。只需要知道它相对于基地址的偏移。

要实现以结构体的方式访问寄存器，就要联系c语言对于结构体的定义（没搞懂，以后再来）


## 使用寄存器编程
学习本时，配合《STM32F10X-中文参考手册》“通用I/O(GPIO)”章节一起阅读

使用寄存器编程只需要最基本的三个文件，联系上面理解（重要文件和是如何包装两个地方）

1. main.c 存放用户代码
2. stm32f10x.h 存放寄存器映射，这样我们就可以不用直接通过地址来修改，而是通过简单易懂的可读变量来修改寄存器
3. startup_stm32f10x_hd.s 这里是放着最基本的启动代码，由汇编语言编写。负责协调调用和启动

### 具体的编程

假设我们需要点亮一个led灯，首先要知道我们该使用什么外设（这不是放屁嘛），我们使用gpio外设，找到对应的端口配置寄存器，要想要点亮led灯的话，就是需要输出。首先先去配置输出类型才行，这里需要使用端口配置低寄存器，配置要的引脚的gpio模式和速度，然后使用端口输出数据寄存器，来进行数据的输出。

是不是忘记了什么？？？为什么不亮？

注意，stm32里还有时钟这个重要的东西，这里的时钟负责（？反正非常重要，外设都离不开时钟），我们需要首先打开时钟。

时钟是另一批的外设，名字是rcc，经过查阅得知，我们要开启apb2总线（也就是所有gpio挂载的地方）的时钟，名字是apb2外设时钟使能寄存器。（注意，是每一个外设有一个时钟，不是每一条gpio线有个时钟）

所以写出了具体的代码（此代码非经过实操，太难了，头痛）

```c
int main(void){
    RCC_APB2ENR |= 1000; // 开启时钟
    GPIOB_CRL &= 1111; // 清空端口位
    GPIOB_CRL |= 0001; // 设置输出模式及速率
    GPIOB_ODR |= 0000; // 输出低电平
}
```

## 使用库编程

使用库来编程，要理解的话，自己写一个库

算了，太复杂了，卡了一个月

以后再来吧
