## 关于中断
中断是有两个种类的，分别是系统中断（系统异常）和外部中断，一里一外。
有关具体的中断可以在标准库文件stm32f10x.h这个头文件中找到，需要就去这里找，是在IRQn_Type这个结构体中。
这里就有个概念，中断的优先级，简单来说就是中断相应紧急程度（你急不急？），大部分中断可以配置优先级，让紧急的中断优先响应。
### 优先级
这里有两个概念，中断有两种优先级
- 响应优先级: 响应优先级高的可以优先响应, 但是仅仅靠这个不可以进行中断嵌套
- 抢占优先级: 抢占优先级高的可以进行中断嵌套
![[Pasted image 20221203193825.png]]
*补充：抢占优先级高的就会抢占抢占优先级低的优先得到执行，如果抢占优先级相同，就比较子优先级。如果抢占优先级和子优先级都相同的话，就比较他们的硬件中断编号，编号越小，优先级越高*

### NVIC
nvic这个是中断控制器，研究和运用中断是绝对离不开这个东西的。
这个nvic负责整个芯片中断的事件，是核心外设
	因为是核心外设，所以nvic放在内核里面，这就引出了另一个注意的，内核中的不需要去开启时钟，因为芯片内核的时钟是时刻运作的，而外面的外设的时钟，为了省电是会自动关闭的，这就是为什么gpio啥的要开启时钟，nvic不需要开启时钟
#### NVIC_IPRx 中断优先级寄存器
上面写了的优先级就是通过这个优先级寄存器来配置的，注意IPR宽度为8bit，故每个外部中断可以配置的优先级为0~255，数值越小，优先级越高。
**特别注意，上面是理论配置，在stm32f103xx中，只使用了高4bit用于表达优先级**

==P231 由于追赶社团进度，跳过研究，一天天追追追，哎，很多都没有仔细学到==


## EXTI 外部中断
这里是外部中断控制器，管理了20个相关事件。每一个中断时间都对应有个边沿检测器负责实现对上升沿检测和下降沿检测（电平信号变动检测）
### EXTI的研究
exti主要分为两个功能，产生中断和产生事件
![[Pasted image 20230302200409.png]]
==跳过==


监测指定gpio口的电平信号 引脚电平变化引起中断
注意相同的pin不能同时执行中断, 因为exit(外部中断检测及控制)只能处理16个gpio口, 但是stm32有多个gpio组, 每个组都有16个gpio口, 所以相同的pin不能同时执行中断(没办法传过去)

外部中断可以从低功耗模式的停止模式唤醒stm32
触发响应方式: 中断响应和事件响应

afio中断引脚选择
且注意 nvic这里将中断5~9, 中断10~15都归于同一个中断, 所以这里两组都只会各自触发一个中断函数
#### 为什么要使用外部中断
对于稍纵即逝的信号，要在能够处理这种信号的同时做其他的事（不想用主循环来读取）

### 外部中断的配置例程
1. 使用**RCC** 将涉及的外设的时钟打开
	1. GPIO：`RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB,ENABLE);`
	2. AFIO：`RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO,ENABLE);`
2. 配置GPIO要携带参数的(结构体)
	1. `GPIO_InitTypeDef GPIO_InitStructure;`
3. 配置**GPIO**
	1. `GPIO_Initstructure.GPIO_Mode = ......`
	2. `GPIO_Init(GPIOB, &GPIO_InitStructure)`
4. 配置**AFIO** 选择我们使用的gpio, 连接到后面的exti
	1. `GPIO_EXTILineConfig(GPIO_PortSourcreGPIOB, GPIO_PinSource14);`
5. 配置**EXTI**, 选择触发方式(上升沿, 下降沿或者双边沿), 以及选择触发响应方式(中断响应和事件响应)
	1. 配置EXTI结构体 `EXTI_InitTypeDef EXTI_InitStructure;`
	2. 配置EXTI
		1. EXTI_Line  上面gpio几号就几号
		2. EXTI_LineCmd （是否启用）
		3. EXTI_Mode （中断模式还是事件）
		4. EXTI_Trigger 触发方式(上升沿, 下降沿或者双边沿)
	3. 传入结构体配置初始化  `EXTI_Init(&...)`
6. 配置**NVIC** 选择合适的优先级
	1. 指定nvic的分组（优先级）`NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2)`
	2. 初始化 跟上面一样
		1. NVIC_IRQChannel （选择中断通道，使用EXTI开头的）
		2. NVIC_IRQChannelCmd （是否使用）
		3. NVIC_IRQChannelPreemption （指定抢占优先级）
		4. NVIC_IRQChannelSubPriority （指定响应优先级）、
7. 复写中断函数，实现中断功能
	1. 在主程序中建立方法
		1. `void EXTI15_10_IRQHandler(void){}` 函数的名字是上面指定的中断通道
			1. 判断，确认中断是由指定的函数触发的
				1. `if (EXTI_GetITStatus(EXTI_Line14) == SET){}`
			2. 编写要处理的
			3. 清除中断标志位
				1. `EXTI_ClearITPendingBit(EXTI_Line14);`

### 注意事项
中断函数中代码运行时间不宜太长。建议是短平快

## TIM
tim可以类似看为一个计数器，它可以对输入的时钟进行计数。并在计数值达到设定值的时候触发中断。
### tim定时中断
#### 概念：
1. cnt计数器 这里接受到上升沿，这里的值便会加1（这里是16位的储存空间）
2. 自动重装寄存器：这里写入我们的计数目标，当计数器中的值等于这里的值就会触发中断和事件（也是16位）
3. 主从触发dac：？？？

#### 注意
基本定时器只能向上计数（0往上递增），通用定时器和高级定时器支持向上计数、向下计数还能中断对齐这三种模式
在基本定时器这里时钟频率只能72Mhz，在通用定时器和高级定时器还可以使用别的时钟
![[Pasted image 20230305224336.png]]
这里有一个自动加载影子寄存器，这个才是真正起作用的，负责同步我们修改的值，但是不仅仅如此，如图所示，这个影子寄存器还能防止中途改变自动加载寄存器而引起错误，让我们的修改没那么及时，这是利大于弊的。只有在下个计数周期我们的更改才有效。

#### 使用实例
1. 开启时钟
	1. `RCC_APB1Peri...`
2. 选择时基单元使用的时钟（内部or外部，默认内部可以不写）
	1. TIM_iNTERNALClockConfig
3. 配置时基单元
	1. ![[Pasted image 20230308200608.png]]
4. 使能中断，开启更新中断到nvic的通路
	1. `TIM_ITConfig(...)`
5. 配置NVIC
	1. nvic分组
	2. 结构体配置nvic
		1. 参考上面的
6. 编写中断函数


### 输出比较
输出比较——最主要的功能就是输出一定频率和占空比的pwm波形（电平不断跳变）
只有通用定时器和高级定时器这里才有输出比较通道（4条，可以输出4路pwm波形）
- 在可以等效实现一个模拟信号的输出，实现电机控速和呼吸灯等
- 频率：1/Ts（越高越精准，但是越耗电）
- 占空比：Ton/Ts（高电平占总的比例，决定了等效模拟电压的大小）
- 分辨率：站空比变化步距

| 模式             | 描述（ccr是自己设置的，cnt不断自增）                        |
| ---------------- | ------------------------------------------------------------ |
| 冻结             | CNT=CCR，但是REF保持位原状态，输出保持最后一个时刻的状态     |
| 匹配时置有效电平 | CNT=CCR，REF（高电平）                                       |
| 匹配时置无效电平 | CNT=CCR，REF（低电平）                                       |
| 匹配时电平翻转   | 可以很好的输出一半一半的波形                                 |
| 强制为无效电平   | 类似于冻结模式，自定义                                       |
| 强制为有效电平   | 类似于冻结模式，自定义                                       |
| pwm模式1         | 向上计数：cnt<cnr时，ref有效电平；cnt>=ccr,ref无效电平。向下计数：cnt>cnr时，ref无效电平；cnt<=ccr,ref有效电平 |
| pwm模式2<p1取反>         | 向上计数：cnt<cnr时，ref无效电平；cnt>=ccr,ref有效电平。向下计数：cnt>cnr时，ref有效电平；cnt<=ccr,ref无效电平 |

tips：

1. pwm1，ccr设置低一点，输出的占空比就变小
1. pwm的频率等于计数器的更新频率
1. 占空比：ccr/（arr+1）

#### 舵机

根据输入pwm信号占空比来控制输出角度，输入pwm信号要求：周期为20ms，高电平宽度为0.5ms~2.5ms
![[Pasted image 20230309161231.png]]

一些引脚说明：

1. vm驱动电压输入端
2. vcc逻辑电平输入端
3. STBY正常工作/待机状态控制输入端（接gnd就不工作，接vcc就工作）
4. ain电机控制模式输入端
5. a0电机驱动输入端

pwm控制速度，引脚控制正转和反转

#### 例子配置

1. RCC开启时钟（需要开启Tim外设和GPIO外设）
   1. `RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2, ENABLE);`
   2. `RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);`
2. 配置时基单元
	1. `TIM_InternalClockConfig(TIM2)`
	2. `TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure;`
	3. `TIM_TimeBaseInitStructure.TIM_ClockDivision = TIM_CKD_DIV1;`
	4. `TIM_TimeBaseInitStructure.TIM_CounterMode = TIM_CounterMode_Up;`
	5. `TIM_TimeBaseInitStructure.TIM_Period = 100 - 1;`
	6. `TIM_TimeBaseInitStructure.TIM_Prescaler = 720 - 1;`
	7. `TIM_TimeBaseInitStructure.TIM_RepetitionCounter = 0;`
	8. `TIM_TimeBaseInit(TIM2, &TIM_TimeBaseInitStructure);`
4. 设置定时器的pwm输出，配置输出比较
	1. `TIM_OCInitTypeDef TIM_OCInitStructure;`
	2. `TIM_OCStructInit(&TIM_OCInitStructure);`
	3. `TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM1;`
	4. `TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_High;`
	5. `TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable;`
	6. `TIM_OCInitStructure.TIM_Pulse = 0;`
	7. `TIM_OC1Init(TIM2, &TIM_OCInitStructure);`
5. 配置GPIO（对应输出口配置为复用推挽输出，必须是复用推挽输出，只有这个才输出pwm，我猜的）
	1. `GPIO_InitTypeDef GPIO_InitStructure;`
	2. `GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;`
	3. `GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0;`
	4. `GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;`
	5. `GPIO_Init(GPIOA, &GPIO_InitStructure);`
6. 运行控制

### 输入捕获

【STM32入门教程-2023持续更新中】 【精准空降到 00:13】 https://www.bilibili.com/video/BV1th411z7sn/?p=17&share_source=copy_web&vd_source=56341c6ca967de83766f14b483eb9ed6&t=13

#### 频率测量
1. 测频法：比较适合高频
2. 测周法：比较适合低频
3. 中界频率